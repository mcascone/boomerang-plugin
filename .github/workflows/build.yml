name: Build

on:
  push:
    branches: ['**']
    paths-ignore:
      - '*.md'
      - '.github/**'
  pull_request:
    branches: [main]
  workflow_dispatch:  # Allow manual trigger

env:
  BUILD_TYPE: Release

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

defaults:
  run:
    shell: bash

jobs:
  build:
    name: Build ${{ matrix.os }}
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
            cmake_flags: -DCMAKE_OSX_ARCHITECTURES="x86_64;arm64" -DCMAKE_OSX_DEPLOYMENT_TARGET=10.13
            artifact_name: boomerang-macos
          - os: windows-latest
            cmake_flags: ""
            artifact_name: boomerang-windows
          - os: ubuntu-latest
            cmake_flags: ""
            artifact_name: boomerang-linux

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          submodules: recursive
          fetch-depth: 0  # Full history for git version

      # Extract version from git (single source of truth)
      - name: Extract Version
        id: version
        run: |
          # Use git describe for version
          # At a tag:    v2.0.0-beta-3 -> 2.0.0-beta-3
          # After a tag: v2.0.0-beta-3-5-g1234abc -> 2.0.0-beta-3+5.g1234abc
          GIT_DESCRIBE=$(git describe --tags --always)
          # Strip 'v' prefix
          VERSION="${GIT_DESCRIBE#v}"
          # Convert git format (tag-N-gHASH) to semver metadata (tag+N.gHASH)
          VERSION=$(echo "$VERSION" | sed -E 's/^(.+)-([0-9]+)-(g[0-9a-f]+)$/\1+\2.\3/')
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version: \`$VERSION\`" >> $GITHUB_STEP_SUMMARY

      # Linux: Install ALSA and other audio dependencies
      - name: Install Linux Dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libasound2-dev \
            libjack-jackd2-dev \
            ladspa-sdk \
            libfreetype6-dev \
            libx11-dev \
            libxcomposite-dev \
            libxcursor-dev \
            libxext-dev \
            libxinerama-dev \
            libxrandr-dev \
            libxrender-dev \
            libwebkit2gtk-4.1-dev \
            libglu1-mesa-dev \
            mesa-common-dev

      # Cache JUCE build artifacts — JUCE rarely changes, so cache based on submodule commit
      - name: Get JUCE commit hash
        id: juce-hash
        run: |
          JUCE_HASH=$(git -C JUCE rev-parse HEAD)
          echo "hash=$JUCE_HASH" >> $GITHUB_OUTPUT
          echo "JUCE submodule: $JUCE_HASH"

      - name: Cache JUCE build
        id: cache-juce
        uses: actions/cache@v4
        with:
          path: |
            build/JUCE
            build/_deps
          # Include 'ninja' suffix on Windows to invalidate old VS-generator caches
          key: juce-${{ runner.os }}${{ runner.os == 'Windows' && '-ninja' || '' }}-${{ steps.juce-hash.outputs.hash }}
          restore-keys: |
            juce-${{ runner.os }}${{ runner.os == 'Windows' && '-ninja' || '' }}-

      - name: Cache status
        run: |
          if [ "${{ steps.cache-juce.outputs.cache-hit }}" == "true" ]; then
            echo "✓ JUCE cache HIT" >> $GITHUB_STEP_SUMMARY
          else
            echo "✗ JUCE cache MISS (will rebuild)" >> $GITHUB_STEP_SUMMARY
          fi

      # Setup ccache for faster compilation (macOS/Linux)
      - name: Setup ccache
        if: runner.os != 'Windows'
        uses: hendrikmuhs/ccache-action@v1
        with:
          key: ${{ runner.os }}-ccache
          verbose: 2

      # Setup sccache for faster compilation (Windows - works with MSVC)
      - name: Setup sccache
        if: runner.os == 'Windows'
        uses: mozilla-actions/sccache-action@v0.0.9

      # Enable sccache GitHub Actions cache for Windows
      - name: Enable sccache GHA cache
        if: runner.os == 'Windows'
        run: echo "SCCACHE_GHA_ENABLED=true" >> $GITHUB_ENV

      # Setup MSVC environment for Ninja on Windows
      - name: Setup MSVC
        if: runner.os == 'Windows'
        uses: ilammy/msvc-dev-cmd@v1

      # Configure CMake
      # Note: Windows uses Ninja generator because CMAKE_*_COMPILER_LAUNCHER
      # does not work with the Visual Studio generator (MSBuild).
      - name: Configure CMake
        run: |
          if [[ "$RUNNER_OS" == "Windows" ]]; then
            cmake -B build -G Ninja -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
              -DCMAKE_C_COMPILER_LAUNCHER=sccache \
              -DCMAKE_CXX_COMPILER_LAUNCHER=sccache \
              ${{ matrix.cmake_flags }}
          else
            cmake -B build -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
              -DCMAKE_C_COMPILER_LAUNCHER=ccache \
              -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
              ${{ matrix.cmake_flags }}
          fi

      # Build
      - name: Build
        run: cmake --build build --config ${{ env.BUILD_TYPE }} --parallel

      # List build artifacts for debugging
      - name: List Artifacts
        run: |
          echo "=== Build Artifacts ==="
          find build -name "*.vst3" -o -name "*.component" -o -name "*.app" -o -name "*.exe" 2>/dev/null || true
          ls -la build/Boomerang_artefacts/ || true

      # Import signing certificates (macOS only)
      - name: Import Signing Certificates
        id: import-certs
        if: runner.os == 'macOS'
        env:
          MACOS_INSTALLER_CERT: ${{ secrets.MACOS_INSTALLER_CERT }}
          MACOS_INSTALLER_CERT_PWD: ${{ secrets.MACOS_INSTALLER_CERT_PWD }}
          MACOS_APPLICATION_CERT: ${{ secrets.MACOS_APPLICATION_CERT }}
          MACOS_APPLICATION_CERT_PWD: ${{ secrets.MACOS_APPLICATION_CERT_PWD }}
        run: |
          # Skip if no certificates configured
          if [ -z "$MACOS_INSTALLER_CERT" ]; then
            echo "::warning::No signing certificates configured — installer will not be signed or notarized"
            echo "can_sign=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/signing.keychain-db
          KEYCHAIN_PWD=$(openssl rand -base64 32)
          
          if ! security create-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN_PATH"; then
            echo "::warning::Failed to create keychain — installer will not be signed"
            echo "can_sign=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PWD" "$KEYCHAIN_PATH"
          
          # Import Developer ID Installer certificate
          echo "$MACOS_INSTALLER_CERT" | base64 --decode > $RUNNER_TEMP/installer_cert.p12
          if ! security import $RUNNER_TEMP/installer_cert.p12 -k "$KEYCHAIN_PATH" \
            -P "$MACOS_INSTALLER_CERT_PWD" -T /usr/bin/productsign -T /usr/bin/pkgbuild -T /usr/bin/productbuild; then
            echo "::warning::Failed to import Installer certificate — installer will not be signed"
            echo "can_sign=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Import Developer ID Application certificate
          echo "$MACOS_APPLICATION_CERT" | base64 --decode > $RUNNER_TEMP/app_cert.p12
          if ! security import $RUNNER_TEMP/app_cert.p12 -k "$KEYCHAIN_PATH" \
            -P "$MACOS_APPLICATION_CERT_PWD" -T /usr/bin/codesign; then
            echo "::warning::Failed to import Application certificate — app will not be signed with hardened runtime"
            echo "can_sign=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Set keychain for signing
          security list-keychains -d user -s "$KEYCHAIN_PATH" login.keychain-db
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PWD" "$KEYCHAIN_PATH"
          
          echo "✓ Certificates imported"
          echo "can_sign=true" >> $GITHUB_OUTPUT

      # Package - macOS
      - name: Package macOS
        if: runner.os == 'macOS'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          mkdir -p dist
          # Create zip with all formats (artifacts are in BUILD_TYPE/ for multi-config builds)
          cd build/Boomerang_artefacts/${{ env.BUILD_TYPE }}
          cp ../../../README.md .
          zip -r ../../../dist/Boomerang-${VERSION}-macOS.zip VST3 AU Standalone README.md
          cd ../../..
          # Build the installer package
          BOOMERANG_VERSION="$VERSION" ./build-installer.sh
          cp build/installer/*.pkg dist/ 2>/dev/null || true
          
          # Report actual signing status
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### macOS Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "Created artifacts for \`$VERSION\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          PKG_FILE=$(ls build/installer/*.pkg 2>/dev/null | head -1)
          if [ -n "$PKG_FILE" ]; then
            if pkgutil --check-signature "$PKG_FILE" 2>/dev/null | grep -q "Developer ID Installer"; then
              echo "✅ Package is **signed** with Developer ID" >> $GITHUB_STEP_SUMMARY
              # Check if notarization ticket is stapled
              if xcrun stapler validate "$PKG_FILE" 2>/dev/null; then
                echo "✅ Package is **notarized** and stapled" >> $GITHUB_STEP_SUMMARY
              else
                echo "⚠️ Package is signed but **not notarized** — Gatekeeper may require internet verification" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "⚠️ **Warning:** Package is **unsigned** — Gatekeeper will block installation. Not suitable for release." >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "⚠️ **Warning:** No .pkg installer was created" >> $GITHUB_STEP_SUMMARY
          fi

      # Package - Windows
      - name: Package Windows
        if: runner.os == 'Windows'
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          mkdir -p dist
          cd build/Boomerang_artefacts/Release
          cp ../../../README.md .
          7z a ../../../dist/Boomerang-${VERSION}-Windows.zip VST3 Standalone README.md
          cd ../../..
          echo "Created Windows artifacts for \`$VERSION\`" >> $GITHUB_STEP_SUMMARY

      # Import GPG key for signing (Linux only)
      - name: Import GPG Key
        id: import-gpg
        if: runner.os == 'Linux'
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          # Skip if no GPG key configured
          if [ -z "$GPG_PRIVATE_KEY" ]; then
            echo "::warning::No GPG key configured — Linux release will not be signed"
            echo "can_sign=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Import the private key (allow warnings/errors during import)
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import 2>/dev/null || true
          
          # Get the key ID for signing
          KEY_ID=$(gpg --list-secret-keys --keyid-format=long 2>/dev/null | grep sec | awk '{print $2}' | cut -d'/' -f2 | head -1 || true)
          if [ -z "$KEY_ID" ]; then
            echo "::warning::Failed to import GPG key — Linux release will not be signed"
            echo "can_sign=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "KEY_ID=$KEY_ID" >> $GITHUB_OUTPUT
          echo "can_sign=true" >> $GITHUB_OUTPUT
          echo "✓ GPG key imported (Key ID: $KEY_ID)"

      # Package - Linux
      - name: Package Linux
        if: runner.os == 'Linux'
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          mkdir -p dist
          cd build/Boomerang_artefacts/Release
          cp ../../../README.md .
          tar -czvf ../../../dist/Boomerang-${VERSION}-Linux.tar.gz VST3 Standalone README.md
          cd ../../..
          
          # Sign the tarball if GPG key is available
          if [ "${{ steps.import-gpg.outputs.can_sign }}" = "true" ]; then
            echo "Signing Linux release..."
            if [ -n "$GPG_PASSPHRASE" ]; then
              echo "$GPG_PASSPHRASE" | gpg --batch --yes --passphrase-fd 0 --pinentry-mode loopback \
                --armor --detach-sign --output "dist/Boomerang-${VERSION}-Linux.tar.gz.asc" \
                "dist/Boomerang-${VERSION}-Linux.tar.gz"
            else
              gpg --batch --yes --armor --detach-sign \
                --output "dist/Boomerang-${VERSION}-Linux.tar.gz.asc" \
                "dist/Boomerang-${VERSION}-Linux.tar.gz"
            fi
            
            # Verify the signature
            echo "Verifying signature..."
            if gpg --verify "dist/Boomerang-${VERSION}-Linux.tar.gz.asc" "dist/Boomerang-${VERSION}-Linux.tar.gz" 2>&1 | tee verify.log && grep -q "Good signature" verify.log; then
              echo "✓ Signature verified successfully"
              SIGNED=true
            else
              echo "::warning::Signature verification failed - see verify.log"
              cat verify.log
              SIGNED=false
            fi
          else
            SIGNED=false
          fi
          
          # Report signing status
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Linux Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "Created artifacts for \`$VERSION\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "$SIGNED" = "true" ]; then
            echo "✅ Release is **GPG signed** with detached signature (\`.asc\` file)" >> $GITHUB_STEP_SUMMARY
            echo "Users can verify authenticity with: \`gpg --verify Boomerang-${VERSION}-Linux.tar.gz.asc\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "⚠️ **Warning:** Release is **unsigned** — users cannot verify authenticity. Not suitable for release." >> $GITHUB_STEP_SUMMARY
          fi

      # Upload artifacts
      - name: Upload Artifacts
        uses: actions/upload-artifact@v6
        with:
          name: ${{ matrix.artifact_name }}
          path: dist/*
          retention-days: 90

  # Validate plugins with pluginval (downloads artifacts from build job - no rebuild)
  validate:
    name: Validate ${{ matrix.os }}
    needs: build
    timeout-minutes: 15
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
            pluginval_url: https://github.com/Tracktion/pluginval/releases/latest/download/pluginval_macOS.zip
            artifact_name: boomerang-macos
            archive_pattern: "Boomerang-*-macOS.zip"
          - os: windows-latest
            pluginval_url: https://github.com/Tracktion/pluginval/releases/latest/download/pluginval_Windows.zip
            artifact_name: boomerang-windows
            archive_pattern: "Boomerang-*-Windows.zip"
          - os: ubuntu-latest
            pluginval_url: https://github.com/Tracktion/pluginval/releases/latest/download/pluginval_Linux.zip
            artifact_name: boomerang-linux
            archive_pattern: "Boomerang-*-Linux.tar.gz"

    runs-on: ${{ matrix.os }}

    steps:
      # Download build artifacts (no checkout/rebuild needed)
      - name: Download Build Artifacts
        uses: actions/download-artifact@v6
        with:
          name: ${{ matrix.artifact_name }}
          path: dist

      # Find the archive file (name includes version)
      - name: Find Archive
        id: find_archive
        run: |
          cd dist
          ARCHIVE=$(ls ${{ matrix.archive_pattern }} 2>/dev/null | head -1)
          if [ -z "$ARCHIVE" ]; then
            echo "Error: No archive matching ${{ matrix.archive_pattern }} found"
            ls -la
            exit 1
          fi
          echo "ARCHIVE=$ARCHIVE" >> $GITHUB_OUTPUT
          echo "Found archive: $ARCHIVE"

      # Extract VST3 from the build archive
      - name: Extract VST3 (macOS/Windows)
        if: runner.os != 'Linux'
        run: |
          mkdir -p extracted
          cd dist
          unzip "${{ steps.find_archive.outputs.ARCHIVE }}" -d ../extracted
          echo "=== Extracted contents ==="
          ls -la ../extracted/

      - name: Extract VST3 (Linux)
        if: runner.os == 'Linux'
        run: |
          mkdir -p extracted
          cd dist
          tar -xzvf "${{ steps.find_archive.outputs.ARCHIVE }}" -C ../extracted
          echo "=== Extracted contents ==="
          ls -la ../extracted/

      # Download pluginval
      - name: Download pluginval
        run: |
          curl -L -o pluginval.zip ${{ matrix.pluginval_url }}
          unzip pluginval.zip -d pluginval

      # Run pluginval against extracted VST3
      - name: Run pluginval
        run: |
          VST3_PATH="extracted/VST3/Boomerang+.vst3"
          echo "Validating: $VST3_PATH"
          if [[ "$RUNNER_OS" == "macOS" ]]; then
            ./pluginval/pluginval.app/Contents/MacOS/pluginval --validate "$VST3_PATH" --strictness-level 5
          elif [[ "$RUNNER_OS" == "Windows" ]]; then
            ./pluginval/pluginval.exe --validate "$VST3_PATH" --strictness-level 5
          else
            # Linux needs Xvfb for headless GUI
            sudo apt-get install -y xvfb
            xvfb-run ./pluginval/pluginval --validate "$VST3_PATH" --strictness-level 5
          fi
